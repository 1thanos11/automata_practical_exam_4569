# 1- Write a function that takes two DFAs and checks if they accept the same language :

from collections import deque

def dfa_equivalence(dfa1, dfa2):
    def symmetric_diff_state(s1, s2):
        return (s1, s2)

    visited = set()
    queue = deque()
    queue.append(symmetric_diff_state(dfa1['start'], dfa2['start']))

    while queue:
        s1, s2 = queue.popleft()

        if (s1 in dfa1['accept']) != (s2 in dfa2['accept']):
            return False

        if (s1, s2) in visited:
            continue
        visited.add((s1, s2))

        for symbol in dfa1['alphabet']:
            next1 = dfa1['transition'].get(s1, {}).get(symbol)
            next2 = dfa2['transition'].get(s2, {}).get(symbol)
            if next1 is None or next2 is None:
                return False 
            queue.append((next1, next2))

    return True


# 2- Write a program that (Cocke–Younger–Kasami) algorithm in Python to determine whether a 
# string belongs to the language generated by a CFG in CNF :

def cyk(cfg, string):
    """
    cfg: dict - {non_terminal: list of productions as strings (like 'AB' or 'a')}
    string: the input string
    """
    n = len(string)
    if n == 0:
        return False  

    table = [[set() for _ in range(n)] for _ in range(n)]

    term_to_nonterm = {}
    for nt, rules in cfg.items():
        for rule in rules:
            if len(rule) == 1 and rule.islower():
                term_to_nonterm.setdefault(rule, set()).add(nt)

    for i in range(n):
        char = string[i]
        if char in term_to_nonterm:
            table[i][i].update(term_to_nonterm[char])

    
    for l in range(2, n + 1):  
        for i in range(n - l + 1):
            j = i + l - 1
            for k in range(i, j):
                for A in cfg:
                    for rule in cfg[A]:
                        if len(rule) == 2:
                            B, C = rule[0], rule[1]
                            if B in cfg and C in cfg:
                                if B in table[i][k] and C in table[k + 1][j]:
                                    table[i][j].add(A)

    return 'S' in table[0][n - 1]




